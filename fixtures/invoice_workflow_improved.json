{
  "name": "Invoice Processing - Improved",
  "description": "Workflow mejorado con detección automática de tipo de PDF",
  "nodes": [
    {
      "id": "start",
      "type": "start",
      "label": "Start"
    },
    {
      "id": "read_email_and_extract_pdf",
      "type": "action",
      "label": "Read Email and Extract PDF",
      "executor": "cached",
      "prompt": "Connect to the email inbox and read the first unread email from mario@bimea.es. Extract email metadata. If there's a PDF attachment, extract it and encode to base64. Mark the email as read. Store in context: email_from, email_subject, email_date, has_pdf (boolean), pdf_filename (if exists), pdf_data (base64 if exists). Use only primitive values.",
      "timeout": 60
    },
    {
      "id": "has_pdf_decision",
      "type": "decision",
      "label": "Has PDF?",
      "executor": "cached",
      "prompt": "Set branch_decision to True if has_pdf is True, False otherwise.",
      "timeout": 10
    },
    {
      "id": "send_rejection_email",
      "type": "action",
      "label": "Send Rejection Email",
      "executor": "cached",
      "prompt": "Send a rejection email to the sender explaining that their email doesn't contain a PDF attachment. Ask them to resend with a PDF. Use the email_from from context as recipient.",
      "timeout": 30
    },
    {
      "id": "check_pdf_type",
      "type": "action",
      "label": "Check PDF Type",
      "executor": "e2b",
      "code": "import fitz  # PyMuPDF\nimport io\nimport base64\nimport json\n\ntry:\n    # Decode PDF from base64\n    pdf_data_base64 = context['pdf_data']\n    pdf_bytes = base64.b64decode(pdf_data_base64)\n    \n    # Open PDF\n    pdf_stream = io.BytesIO(pdf_bytes)\n    doc = fitz.open(stream=pdf_stream, filetype='pdf')\n    \n    # Extract text from first page\n    first_page_text = doc[0].get_text()\n    text_length = len(first_page_text.strip())\n    \n    doc.close()\n    \n    # Classify PDF based on text amount\n    if text_length > 100:\n        pdf_type = 'digital'\n        recommended_method = 'text'\n    elif text_length > 0:\n        pdf_type = 'hybrid'\n        recommended_method = 'ocr'\n    else:\n        pdf_type = 'scanned'\n        recommended_method = 'ocr'\n    \n    # Update context\n    context['pdf_type'] = pdf_type\n    context['pdf_text_length'] = text_length\n    context['pdf_has_text_layer'] = text_length > 0\n    context['recommended_extraction_method'] = recommended_method\n    \nexcept Exception as e:\n    context['pdf_type'] = 'unknown'\n    context['recommended_extraction_method'] = 'text'\n    context['check_pdf_error'] = str(e)",
      "timeout": 30
    },
    {
      "id": "extract_text_from_pdf",
      "type": "action",
      "label": "Extract Text from PDF",
      "executor": "cached",
      "prompt": "Extract all text content from the PDF. The PDF is base64-encoded in context['pdf_data']. Use context['recommended_extraction_method'] and context['pdf_type'] to decide the best approach. Extract text from ALL pages and store the complete result in context['ocr_text']. Also store the library/method you used in context['extraction_method_used'].",
      "timeout": 90
    },
    {
      "id": "find_total_amount",
      "type": "action",
      "label": "Find Total Amount",
      "executor": "cached",
      "prompt": "Find the total invoice amount from the extracted text in context['ocr_text']. Look for common invoice total indicators in Spanish. Handle European number formats. Store the amount as a float in context['total_amount']. If not found, set to 0.0.",
      "timeout": 30
    },
    {
      "id": "amount_decision",
      "type": "decision",
      "label": "Amount > €1000?",
      "executor": "cached",
      "prompt": "Set branch_decision to True if total_amount > 1000, False otherwise.",
      "timeout": 10
    },
    {
      "id": "send_high_budget_email",
      "type": "action",
      "label": "Send High Budget Email",
      "executor": "cached",
      "prompt": "Send an email to the sender notifying that the invoice amount exceeds the €1000 threshold and will require manual review. Use email_from from context as recipient.",
      "timeout": 30
    },
    {
      "id": "save_invoice_to_db",
      "type": "action",
      "label": "Save Invoice to Database",
      "executor": "cached",
      "prompt": "Save the invoice to the database 'invoices' table. Store the PDF (decode from base64), extracted text, amount, sender info, and extraction method used. Set currency to EUR. Return the inserted record ID.",
      "timeout": 60
    },
    {
      "id": "end",
      "type": "end",
      "label": "End"
    }
  ],
  "edges": [
    {
      "from": "start",
      "to": "read_email_and_extract_pdf"
    },
    {
      "from": "read_email_and_extract_pdf",
      "to": "has_pdf_decision"
    },
    {
      "from": "has_pdf_decision",
      "to": "send_rejection_email",
      "condition": "false"
    },
    {
      "from": "has_pdf_decision",
      "to": "check_pdf_type",
      "condition": "true"
    },
    {
      "from": "send_rejection_email",
      "to": "end"
    },
    {
      "from": "check_pdf_type",
      "to": "extract_text_from_pdf"
    },
    {
      "from": "extract_text_from_pdf",
      "to": "find_total_amount"
    },
    {
      "from": "find_total_amount",
      "to": "amount_decision"
    },
    {
      "from": "amount_decision",
      "to": "send_high_budget_email",
      "condition": "true"
    },
    {
      "from": "amount_decision",
      "to": "save_invoice_to_db",
      "condition": "false"
    },
    {
      "from": "send_high_budget_email",
      "to": "save_invoice_to_db"
    },
    {
      "from": "save_invoice_to_db",
      "to": "end"
    }
  ]
}
