"""
Chain of Work Step Model

Detailed audit trail of each internal agent execution within a node.

Each row represents ONE agent execution. A single workflow node (ActionNode with
CachedExecutor) may generate 4-14 steps depending on retries:

Example (2 attempts):
  1. InputAnalyzer (attempt 1)
  2. DataAnalyzer (attempt 1) - optional
  3. CodeGenerator (attempt 1)
  4. CodeValidator (attempt 1)
  5. E2BExecutor (attempt 1) - failed
  6. CodeGenerator (attempt 2)
  7. CodeValidator (attempt 2)
  8. E2BExecutor (attempt 2) - success
  9. OutputValidator (attempt 2)

Total: 9 steps for 1 node with 2 attempts
"""

from sqlalchemy import Column, Integer, String, Text, JSON, DateTime, Float, ForeignKey, Index
from sqlalchemy.orm import relationship
from datetime import datetime
from . import Base


class ChainOfWorkStep(Base):
    """
    Chain of Work Step - Granular execution trace of internal agent executions.

    This table provides complete traceability of what happens INSIDE a workflow node
    when using CachedExecutor (Mark I multi-agent system).

    Use cases:
    - Debugging: "Why did this node fail? Which agent caused the error?"
    - Analytics: "What's the average retry rate? Which agent is slowest?"
    - Cost tracking: "How much did each agent cost across all executions?"
    - Optimization: "Can we reduce retries by improving CodeGenerator prompts?"
    """
    __tablename__ = "chain_of_work_steps"

    # Primary key
    id = Column(Integer, primary_key=True, index=True)

    # Foreign key to parent ChainOfWork (cascade delete)
    chain_of_work_id = Column(
        Integer,
        ForeignKey("chain_of_work.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )

    # ==================== STEP IDENTIFICATION ====================

    step_number = Column(Integer, nullable=False)
    """
    Sequential step number within the node execution (1, 2, 3, 4, 5, 6).

    Mapping:
    - 1: InputAnalyzer (always present)
    - 2: DataAnalyzer (only if needs_analysis=true)
    - 3: CodeGenerator (retry loop)
    - 4: CodeValidator (retry loop)
    - 5: E2BExecutor (retry loop)
    - 6: OutputValidator (retry loop)
    """

    step_name = Column(String(100), nullable=False, index=True)
    """
    Human-readable step name.

    Values:
    - "input_analysis"
    - "data_analysis"
    - "code_generation"
    - "code_validation"
    - "e2b_execution"
    - "output_validation"
    """

    agent_name = Column(String(100), nullable=False, index=True)
    """
    Agent class name that executed this step.

    Values:
    - "InputAnalyzer"
    - "DataAnalyzer"
    - "CodeGenerator"
    - "CodeValidator"
    - "E2BExecutor"
    - "OutputValidator"
    """

    attempt_number = Column(Integer, default=1, index=True)
    """
    Retry attempt number (1, 2, 3).

    Only steps 3-6 (retry loop) can have attempt_number > 1.
    Steps 1-2 always have attempt_number = 1.
    """

    # ==================== STEP INPUT/OUTPUT ====================

    input_data = Column(JSON, nullable=True)
    """
    Input data that the agent received.

    Examples:

    InputAnalyzer:
    {
      "task": "Extract total from PDF",
      "context_keys": ["pdf_path", "user_id"]
    }

    CodeGenerator:
    {
      "task": "Extract total from PDF",
      "context": {"pdf_path": "/tmp/invoice.pdf"},
      "data_insights": {"num_pages": 3, "first_page_preview": "..."},
      "error_history": [
        {"stage": "execution", "error": "FileNotFound", "attempt": 1}
      ]
    }

    E2BExecutor:
    {
      "code": "import fitz\n...",
      "context": {"pdf_path": "/tmp/invoice.pdf"}
    }

    Note: Large values (>100KB) may be truncated to prevent DB bloat.
    """

    output_data = Column(JSON, nullable=True)
    """
    Output data that the agent returned.

    Examples:

    InputAnalyzer:
    {
      "needs_analysis": true,
      "complexity": "medium",
      "reasoning": "PDF file requires structure inspection"
    }

    CodeGenerator:
    {
      "code": "import fitz\n...",
      "tool_calls": [...],
      "model": "gpt-4o"
    }

    E2BExecutor:
    {
      "context_updates": {
        "total_amount": 1234.56,
        "vendor": "ACME Corp"
      }
    }

    CodeValidator:
    {
      "valid": true,
      "errors": []
    }

    OutputValidator:
    {
      "valid": true,
      "changes_detected": ["total_amount", "vendor"],
      "reasoning": "Task completed successfully"
    }
    """

    # ==================== CODE GENERATION ====================

    generated_code = Column(Text, nullable=True)
    """
    Python code generated by the agent (only for CodeGenerator, DataAnalyzer).

    Example:
    ```python
    import fitz
    import re

    pdf = fitz.open(context['pdf_path'])
    text = ''
    for page in pdf:
        text += page.get_text()

    match = re.search(r'Total[:\\s]+\\$?([0-9,]+\\.\\d{2})', text)
    if match:
        total = match.group(1).replace(',', '')
        context['total_amount'] = float(total)
    ```

    This is the ACTUAL code that was validated/executed, not the prompt.
    """

    # ==================== E2B EXECUTION ====================

    sandbox_id = Column(String(255), nullable=True)
    """
    E2B sandbox ID (only for E2BExecutor steps).

    Example: "sbx_abc123xyz"

    Useful for debugging E2B issues or correlating with E2B logs.
    """

    # ==================== AI METADATA ====================

    model_used = Column(String(50), nullable=True)
    """
    AI model used (only for AI agents: InputAnalyzer, CodeGenerator, OutputValidator).

    Values:
    - "gpt-4o-mini"
    - "gpt-4o"
    - "o1-preview"
    - null (for CodeValidator, E2BExecutor)
    """

    tokens_input = Column(Integer, nullable=True)
    """
    Number of input tokens consumed by the AI model.

    Used for cost tracking and optimization.
    Only populated for AI agents (InputAnalyzer, CodeGenerator, OutputValidator).
    """

    tokens_output = Column(Integer, nullable=True)
    """
    Number of output tokens generated by the AI model.

    Used for cost tracking and optimization.
    Only populated for AI agents.
    """

    cost_usd = Column(Float, nullable=True)
    """
    Cost in USD for this specific agent execution.

    Calculation:
    - AI agents: Based on tokens_input * input_price + tokens_output * output_price
    - E2BExecutor: Based on execution time (~$0.03/second)
    - CodeValidator: Always $0 (no AI, no external service)

    Example:
    - InputAnalyzer: $0.0002
    - CodeGenerator: $0.0030
    - E2BExecutor: $0.0010
    - CodeValidator: $0.0000
    - OutputValidator: $0.0005
    """

    # ==================== TOOL CALLING (RAG) ====================

    tool_calls = Column(JSON, nullable=True)
    """
    Tool calls made by the agent (only for CodeGenerator with RAG).

    Example:
    [
      {
        "function": "search_documentation",
        "arguments": {
          "library": "pymupdf",
          "query": "extract text from PDF",
          "top_k": 3
        },
        "result": "# PyMuPDF Documentation\\n\\n## Extracting Text..."
      }
    ]

    This tracks when the agent searches for documentation to generate better code.
    Useful for analyzing RAG effectiveness.
    """

    # ==================== EXECUTION STATUS ====================

    status = Column(String(50), nullable=False, index=True)
    """
    Execution status of this step.

    Values:
    - "success": Step completed successfully
    - "failed": Step failed (error in error_message)

    Note: Even if status="failed", the workflow may succeed in a later retry.
    """

    error_message = Column(Text, nullable=True)
    """
    Error message if step failed.

    Examples:

    CodeValidator:
    "Variable 'total' used before definition at line 12"

    E2BExecutor:
    "FileNotFoundError: /tmp/invoice.pdf not found"

    OutputValidator:
    "Task 'Extract total amount' NOT completed. No 'total_amount' key added to context."
    """

    execution_time_ms = Column(Float, nullable=False)
    """
    Execution time in milliseconds.

    Typical values:
    - InputAnalyzer: ~250ms
    - DataAnalyzer: ~1500ms (includes E2B execution)
    - CodeGenerator: ~1800ms (includes OpenAI API + RAG)
    - CodeValidator: ~15ms (AST parsing is fast)
    - E2BExecutor: ~1200ms (sandbox startup + execution)
    - OutputValidator: ~400ms

    Used for performance analysis and optimization.
    """

    timestamp = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    """
    When this step was executed (UTC).

    Useful for:
    - Ordering steps chronologically
    - Analyzing execution patterns over time
    - Correlating with external logs (E2B, OpenAI)
    """

    # ==================== RELATIONSHIPS ====================

    chain_of_work = relationship(
        "ChainOfWork",
        back_populates="steps"
    )
    """
    Relationship to parent ChainOfWork entry.

    Usage:
    step.chain_of_work.node_id  # "extract_data"
    step.chain_of_work.execution.workflow.name  # "Invoice Processing"
    """

    # ==================== INDEXES ====================

    __table_args__ = (
        # Composite index for common query: "Get all steps for a node, ordered"
        Index('idx_chain_steps_chain_order', 'chain_of_work_id', 'step_number', 'attempt_number'),

        # Index for analytics: "Find all failed steps"
        Index('idx_chain_steps_status_time', 'status', 'timestamp'),

        # Index for cost analysis: "Sum costs by agent"
        Index('idx_chain_steps_agent_cost', 'agent_name', 'cost_usd'),
    )

    # ==================== METHODS ====================

    def __repr__(self):
        return (
            f"<ChainOfWorkStep("
            f"id={self.id}, "
            f"chain_of_work_id={self.chain_of_work_id}, "
            f"step={self.step_number}, "
            f"agent='{self.agent_name}', "
            f"attempt={self.attempt_number}, "
            f"status='{self.status}'"
            f")>"
        )

    def to_dict(self):
        """
        Convert to dictionary for JSON serialization.

        Useful for API responses or debugging.
        """
        return {
            "id": self.id,
            "chain_of_work_id": self.chain_of_work_id,
            "step_number": self.step_number,
            "step_name": self.step_name,
            "agent_name": self.agent_name,
            "attempt_number": self.attempt_number,
            "input_data": self.input_data,
            "output_data": self.output_data,
            "generated_code": self.generated_code,
            "sandbox_id": self.sandbox_id,
            "model_used": self.model_used,
            "tokens_input": self.tokens_input,
            "tokens_output": self.tokens_output,
            "cost_usd": self.cost_usd,
            "tool_calls": self.tool_calls,
            "status": self.status,
            "error_message": self.error_message,
            "execution_time_ms": self.execution_time_ms,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None
        }

    @property
    def is_retry(self):
        """Returns True if this is a retry attempt (attempt_number > 1)"""
        return self.attempt_number > 1

    @property
    def is_ai_agent(self):
        """Returns True if this agent uses AI (has model_used)"""
        return self.model_used is not None

    @property
    def has_error(self):
        """Returns True if this step failed"""
        return self.status == "failed"
